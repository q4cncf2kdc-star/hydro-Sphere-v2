<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Ultra Realistic Water Sphere</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      overflow: hidden;
    }
    body {
      background: #000;
      touch-action: none;
    }
    canvas {
      width: 100%;
      height: 100vh;
      display: block;
    }
    .info {
      position: absolute;
      top: 20px;
      left: 20px;
      color: rgba(255,255,255,0.9);
      font-family: monospace;
      font-size: 13px;
      background: rgba(0,20,40,0.8);
      padding: 12px;
      border-radius: 8px;
      pointer-events: none;
      border: 1px solid rgba(0,150,255,0.3);
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <div class="info">Drag to interact â€¢ Enhanced water physics</div>

  <script>
    const canvas = document.getElementById('canvas');
    const gl = canvas.getContext('webgl', { antialias: true, alpha: false });

    if (!gl) {
      alert('WebGL not supported');
    }

    const vertexShaderSource = `
      attribute vec2 position;
      void main() {
        gl_Position = vec4(position, 0.0, 1.0);
      }
    `;

    const fragmentShaderSource = `
      precision highp float;

      uniform float uTime;
      uniform vec2 uResolution;
      uniform vec2 uMouse;
      uniform float uInteracting;

      #define STEPS 50
      #define MAX_DIST 8.0
      #define SURF_DIST 0.001
      #define PI 3.14159265359
      #define TAU 6.28318530718

      // Enhanced hash for better randomness
      float hash13(vec3 p3) {
        p3 = fract(p3 * 0.1031);
        p3 += dot(p3, p3.zyx + 31.32);
        return fract((p3.x + p3.y) * p3.z);
      }

      vec3 hash33(vec3 p3) {
        p3 = fract(p3 * vec3(0.1031, 0.1030, 0.0973));
        p3 += dot(p3, p3.yxz + 33.33);
        return fract((p3.xxy + p3.yxx) * p3.zyx);
      }

      // Perlin-like noise for organic motion
      float noise(vec3 p) {
        vec3 i = floor(p);
        vec3 f = fract(p);
        f = f * f * (3.0 - 2.0 * f);

        return mix(
          mix(mix(hash13(i), hash13(i + vec3(1,0,0)), f.x),
              mix(hash13(i + vec3(0,1,0)), hash13(i + vec3(1,1,0)), f.x), f.y),
          mix(mix(hash13(i + vec3(0,0,1)), hash13(i + vec3(1,0,1)), f.x),
              mix(hash13(i + vec3(0,1,1)), hash13(i + vec3(1,1,1)), f.x), f.y),
          f.z
        );
      }

      // Fractal Brownian Motion for water waves
      float fbm(vec3 p) {
        float value = 0.0;
        float amplitude = 0.5;
        float frequency = 1.0;
        for(int i = 0; i < 5; i++) {
          value += amplitude * noise(p * frequency);
          frequency *= 2.1;
          amplitude *= 0.45;
        }
        return value;
      }

      // Sphere SDF
      float sdSphere(vec3 p, float r) {
        return length(p) - r;
      }

      // Water displacement with realistic wave patterns
      float waterDisplacement(vec3 p, float time) {
        // Multiple wave layers at different scales
        float wave1 = fbm(p * 2.0 + vec3(time * 0.3, time * 0.2, 0.0));
        float wave2 = fbm(p * 4.0 - vec3(time * 0.4, time * 0.3, time * 0.1));
        float wave3 = fbm(p * 8.0 + vec3(time * 0.2, -time * 0.4, time * 0.2));

        // Combine waves with different weights
        float waves = wave1 * 0.5 + wave2 * 0.3 + wave3 * 0.2;

        // Add surface tension ripples
        float ripple = sin(length(p.xy) * 20.0 - time * 4.0) * 0.02;

        return waves * 0.12 + ripple;
      }

      // Main distance field
      float map(vec3 p) {
        vec3 q = p;
        float t = uTime * 0.5;

        // Mouse interaction creates realistic water distortion
        vec2 mouseWorld = (uMouse * 2.0 - 1.0) * vec2(uResolution.x / uResolution.y, 1.0);
        vec3 mousePos = vec3(mouseWorld * 1.8, 0.0);
        float mouseDist = length(p - mousePos);

        // Smooth ripple from touch
        float mouseWave = sin(mouseDist * 8.0 - uTime * 6.0) * exp(-mouseDist * 2.0);
        float mouseEffect = mouseWave * uInteracting * 0.25;

        // Apply water displacement
        float disp = waterDisplacement(q, t);
        q += normalize(p) * (disp + mouseEffect);

        // Base sphere with subtle variation
        float sphere = sdSphere(q, 1.0);

        // Add fine detail
        sphere += sin(p.x * 15.0 + t * 2.0) * sin(p.y * 15.0) * sin(p.z * 15.0) * 0.008;

        return sphere;
      }

      // High quality normal calculation
      vec3 calcNormal(vec3 p) {
        vec2 e = vec2(0.001, 0.0);
        return normalize(vec3(
          map(p + e.xyy) - map(p - e.xyy),
          map(p + e.yxy) - map(p - e.yxy),
          map(p + e.yyx) - map(p - e.yyx)
        ));
      }

      // Ambient occlusion for depth
      float calcAO(vec3 p, vec3 n) {
        float occ = 0.0;
        float sca = 1.0;
        for(int i = 0; i < 5; i++) {
          float h = 0.01 + 0.15 * float(i) / 4.0;
          float d = map(p + h * n);
          occ += (h - d) * sca;
          sca *= 0.92;
        }
        return clamp(1.0 - 1.8 * occ, 0.0, 1.0);
      }

      // Soft shadows
      float calcShadow(vec3 p, vec3 lightDir) {
        float res = 1.0;
        float t = 0.02;
        for(int i = 0; i < 16; i++) {
          float h = map(p + lightDir * t);
          res = min(res, 8.0 * h / t);
          t += h;
          if(res < 0.001 || t > 2.0) break;
        }
        return clamp(res, 0.0, 1.0);
      }

      // Refraction calculation
      vec3 refract3(vec3 i, vec3 n, float eta) {
        float cosi = dot(-i, n);
        float cost2 = 1.0 - eta * eta * (1.0 - cosi * cosi);
        vec3 t = eta * i + ((eta * cosi - sqrt(abs(cost2))) * n);
        return t * vec3(cost2 > 0.0);
      }

      void main() {
        vec2 uv = (gl_FragCoord.xy / uResolution.xy) * 2.0 - 1.0;
        uv.x *= uResolution.x / uResolution.y;

        // Camera setup with subtle movement
        vec3 ro = vec3(0.0, 0.0, 3.8);
        float angle = uTime * 0.12;
        ro.xz = mat2(cos(angle), -sin(angle), sin(angle), cos(angle)) * ro.xz;
        ro.y += sin(uTime * 0.15) * 0.2;

        vec3 target = vec3(0.0);
        vec3 forward = normalize(target - ro);
        vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));
        vec3 up = cross(forward, right);

        vec3 rd = normalize(uv.x * right + uv.y * up + forward * 1.6);

        // Ray marching
        float t = 0.0;
        vec3 p;
        float d = 0.0;
        bool hit = false;

        for(int i = 0; i < STEPS; i++) {
          p = ro + rd * t;
          d = map(p);
          if(abs(d) < SURF_DIST) {
            hit = true;
            break;
          }
          if(t > MAX_DIST) break;
          t += d * 0.8;
        }

        // Background gradient
        vec3 bgColor = mix(vec3(0.02, 0.05, 0.1), vec3(0.0, 0.1, 0.2), uv.y * 0.5 + 0.5);
        vec3 col = bgColor;

        if(hit) {
          vec3 n = calcNormal(p);

          // Multiple light sources
          vec3 lightPos1 = vec3(3.0, 4.0, 5.0);
          vec3 lightPos2 = vec3(-2.0, 2.0, 3.0);

          vec3 lightDir1 = normalize(lightPos1 - p);
          vec3 lightDir2 = normalize(lightPos2 - p);

          // Diffuse lighting
          float diff1 = max(dot(n, lightDir1), 0.0);
          float diff2 = max(dot(n, lightDir2), 0.0) * 0.5;
          float diff = diff1 + diff2;

          // Specular highlights (Blinn-Phong)
          vec3 halfDir1 = normalize(lightDir1 - rd);
          float spec1 = pow(max(dot(n, halfDir1), 0.0), 64.0);
          vec3 halfDir2 = normalize(lightDir2 - rd);
          float spec2 = pow(max(dot(n, halfDir2), 0.0), 32.0) * 0.5;
          float spec = spec1 + spec2;

          // Fresnel effect (Schlick's approximation)
          float fresnel = pow(1.0 - max(dot(n, -rd), 0.0), 5.0);
          fresnel = 0.02 + 0.98 * fresnel;

          // Ambient occlusion
          float ao = calcAO(p, n);

          // Shadows
          float shadow1 = calcShadow(p + n * 0.02, lightDir1);
          float shadow2 = calcShadow(p + n * 0.02, lightDir2);

          // Subsurface scattering approximation
          float sss1 = pow(clamp(dot(-lightDir1, n) * 0.5 + 0.5, 0.0, 1.0), 3.0);
          float sss2 = pow(clamp(dot(-lightDir2, n) * 0.5 + 0.5, 0.0, 1.0), 3.0);
          float sss = (sss1 + sss2 * 0.5) * 0.4;

          // Refraction for depth
          vec3 refractDir = refract3(rd, n, 0.75);
          float refractColor = noise(p + refractDir * 0.5) * 0.3;

          // Water color gradient (deep to shallow)
          vec3 deepWater = vec3(0.0, 0.08, 0.25);
          vec3 shallowWater = vec3(0.05, 0.35, 0.7);
          vec3 surfaceWater = vec3(0.3, 0.7, 1.0);

          vec3 waterColor = mix(deepWater, shallowWater, fresnel * 0.5);
          waterColor = mix(waterColor, surfaceWater, fresnel * fresnel);

          // Combine all lighting
          col = waterColor * (diff * 0.7 + 0.3) * ao * shadow1;
          col += waterColor * diff2 * ao * shadow2 * 0.5;
          col += vec3(0.8, 0.95, 1.0) * spec * 3.0;
          col += waterColor * sss;
          col += surfaceWater * fresnel * 0.8;
          col += refractColor * waterColor * 0.3;

          // Depth fog
          float fog = exp(-t * 0.15);
          col = mix(bgColor, col, fog);
        }

        // Enhanced tone mapping (ACES)
        col = col / (col + vec3(0.155)) * 1.019;

        // Gamma correction
        col = pow(col, vec3(0.75));

        // Slight vignette
        float vignette = 1.0 - length(uv) * 0.15;
        col *= vignette;

        gl_FragColor = vec4(col, 1.0);
      }
    `;

    function compileShader(source, type) {
      const shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);

      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error('Shader compile error:', gl.getShaderInfoLog(shader));
        gl.deleteShader(shader);
        return null;
      }
      return shader;
    }

    const vertexShader = compileShader(vertexShaderSource, gl.VERTEX_SHADER);
    const fragmentShader = compileShader(fragmentShaderSource, gl.FRAGMENT_SHADER);

    const program = gl.createProgram();
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);

    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
      console.error('Program link error:', gl.getProgramInfoLog(program));
    }

    const vertices = new Float32Array([
      -1, -1,
      1, -1,
      -1, 1,
      1, 1
    ]);

    const buffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

    const positionLocation = gl.getAttribLocation(program, 'position');
    gl.enableVertexAttribArray(positionLocation);
    gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

    const uTimeLocation = gl.getUniformLocation(program, 'uTime');
    const uResolutionLocation = gl.getUniformLocation(program, 'uResolution');
    const uMouseLocation = gl.getUniformLocation(program, 'uMouse');
    const uInteractingLocation = gl.getUniformLocation(program, 'uInteracting');

    gl.useProgram(program);

    let mouseX = 0.5;
    let mouseY = 0.5;
    let isInteracting = 0.0;
    let targetInteracting = 0.0;

    function handleMove(x, y) {
      mouseX = x / canvas.width;
      mouseY = 1.0 - (y / canvas.height);
      targetInteracting = 1.0;
    }

    canvas.addEventListener('mousemove', (e) => {
      if (e.buttons > 0) {
        handleMove(e.offsetX, e.offsetY);
      }
    });

    canvas.addEventListener('mousedown', (e) => {
      handleMove(e.offsetX, e.offsetY);
    });

    canvas.addEventListener('mouseup', () => {
      targetInteracting = 0.0;
    });

    canvas.addEventListener('touchmove', (e) => {
      e.preventDefault();
      const touch = e.touches[0];
      const rect = canvas.getBoundingClientRect();
      const x = (touch.clientX - rect.left) * (canvas.width / rect.width);
      const y = (touch.clientY - rect.top) * (canvas.height / rect.height);
      handleMove(x, y);
    });

    canvas.addEventListener('touchstart', (e) => {
      const touch = e.touches[0];
      const rect = canvas.getBoundingClientRect();
      const x = (touch.clientX - rect.left) * (canvas.width / rect.width);
      const y = (touch.clientY - rect.top) * (canvas.height / rect.height);
      handleMove(x, y);
    });

    canvas.addEventListener('touchend', () => {
      targetInteracting = 0.0;
    });

    function resize() {
      const dpr = Math.min(window.devicePixelRatio, 2);
      canvas.width = canvas.clientWidth * dpr;
      canvas.height = canvas.clientHeight * dpr;
      gl.viewport(0, 0, canvas.width, canvas.height);
    }

    resize();
    window.addEventListener('resize', resize);

    const startTime = Date.now();

    function render() {
      const time = (Date.now() - startTime) * 0.001;

      isInteracting += (targetInteracting - isInteracting) * 0.08;

      gl.uniform1f(uTimeLocation, time);
      gl.uniform2f(uResolutionLocation, canvas.width, canvas.height);
      gl.uniform2f(uMouseLocation, mouseX, mouseY);
      gl.uniform1f(uInteractingLocation, isInteracting);

      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
      requestAnimationFrame(render);
    }

    render();
  </script>
</body>
</html>
